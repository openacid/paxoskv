// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: paxoskv.proto

package paxoskv

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Op int32

const (
	Op_Noop   Op = 0
	Op_Accept Op = 1
	Op_Commit Op = 2
)

var Op_name = map[int32]string{
	0: "Noop",
	1: "Accept",
	2: "Commit",
}

var Op_value = map[string]int32{
	"Noop":   0,
	"Accept": 1,
	"Commit": 2,
}

func (x Op) String() string {
	return proto.EnumName(Op_name, int32(x))
}

func (Op) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2fd9fc43023b527a, []int{0}
}

type Request struct {
	Op        Op             `protobuf:"varint,1,opt,name=Op,proto3,enum=paxoskv.Op" json:"Op,omitempty"`
	Bal       *BallotNum     `protobuf:"bytes,5,opt,name=Bal,proto3" json:"Bal,omitempty"`
	Column    int64          `protobuf:"varint,10,opt,name=Column,proto3" json:"Column,omitempty"`
	Instances map[int64]*Ins `protobuf:"bytes,20,rep,name=Instances,proto3" json:"Instances,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Request) Reset()         { *m = Request{} }
func (m *Request) String() string { return proto.CompactTextString(m) }
func (*Request) ProtoMessage()    {}
func (*Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fd9fc43023b527a, []int{0}
}
func (m *Request) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request.Merge(m, src)
}
func (m *Request) XXX_Size() int {
	return m.Size()
}
func (m *Request) XXX_DiscardUnknown() {
	xxx_messageInfo_Request.DiscardUnknown(m)
}

var xxx_messageInfo_Request proto.InternalMessageInfo

type Reply struct {
	LastBal   *BallotNum     `protobuf:"bytes,5,opt,name=LastBal,proto3" json:"LastBal,omitempty"`
	Instances map[int64]*Ins `protobuf:"bytes,20,rep,name=Instances,proto3" json:"Instances,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Reply) Reset()         { *m = Reply{} }
func (m *Reply) String() string { return proto.CompactTextString(m) }
func (*Reply) ProtoMessage()    {}
func (*Reply) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fd9fc43023b527a, []int{1}
}
func (m *Reply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Reply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Reply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Reply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Reply.Merge(m, src)
}
func (m *Reply) XXX_Size() int {
	return m.Size()
}
func (m *Reply) XXX_DiscardUnknown() {
	xxx_messageInfo_Reply.DiscardUnknown(m)
}

var xxx_messageInfo_Reply proto.InternalMessageInfo

// BallotNum is the ballot number in paxos. It consists of a monotonically
// incremental number and a universally unique ProposerId.
type BallotNum struct {
	N  int64 `protobuf:"varint,1,opt,name=N,proto3" json:"N,omitempty"`
	Id int64 `protobuf:"varint,2,opt,name=Id,proto3" json:"Id,omitempty"`
}

func (m *BallotNum) Reset()         { *m = BallotNum{} }
func (m *BallotNum) String() string { return proto.CompactTextString(m) }
func (*BallotNum) ProtoMessage()    {}
func (*BallotNum) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fd9fc43023b527a, []int{2}
}
func (m *BallotNum) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BallotNum) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BallotNum.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BallotNum) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BallotNum.Merge(m, src)
}
func (m *BallotNum) XXX_Size() int {
	return m.Size()
}
func (m *BallotNum) XXX_DiscardUnknown() {
	xxx_messageInfo_BallotNum.DiscardUnknown(m)
}

var xxx_messageInfo_BallotNum proto.InternalMessageInfo

// Cmd is the value in this paxos impl, which is a command to set a key-value
// record.
// In this demo it is just string key and a int64 value.
type Cmd struct {
	Key  string `protobuf:"bytes,3,opt,name=Key,proto3" json:"Key,omitempty"`
	Vi64 int64  `protobuf:"varint,4,opt,name=Vi64,proto3" json:"Vi64,omitempty"`
}

func (m *Cmd) Reset()         { *m = Cmd{} }
func (m *Cmd) String() string { return proto.CompactTextString(m) }
func (*Cmd) ProtoMessage()    {}
func (*Cmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fd9fc43023b527a, []int{3}
}
func (m *Cmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Cmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Cmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Cmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cmd.Merge(m, src)
}
func (m *Cmd) XXX_Size() int {
	return m.Size()
}
func (m *Cmd) XXX_DiscardUnknown() {
	xxx_messageInfo_Cmd.DiscardUnknown(m)
}

var xxx_messageInfo_Cmd proto.InternalMessageInfo

// InsId is the id of an instance.
// The tuple (column, lsn, proposer_id) identifies a proposed value.
// Two proposers may propose a same Cmd, in which case
// these two must be distinguishable, otherwise a Write operation may be
// lost.
type InsId struct {
	Column int64 `protobuf:"varint,1,opt,name=Column,proto3" json:"Column,omitempty"`
	// LSN: log-sequence-number
	LSN int64 `protobuf:"varint,5,opt,name=LSN,proto3" json:"LSN,omitempty"`
	// ProposerId is the server id that proposes an instance.
	ProposerId int64 `protobuf:"varint,10,opt,name=ProposerId,proto3" json:"ProposerId,omitempty"`
}

func (m *InsId) Reset()         { *m = InsId{} }
func (m *InsId) String() string { return proto.CompactTextString(m) }
func (*InsId) ProtoMessage()    {}
func (*InsId) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fd9fc43023b527a, []int{4}
}
func (m *InsId) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InsId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InsId.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InsId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InsId.Merge(m, src)
}
func (m *InsId) XXX_Size() int {
	return m.Size()
}
func (m *InsId) XXX_DiscardUnknown() {
	xxx_messageInfo_InsId.DiscardUnknown(m)
}

var xxx_messageInfo_InsId proto.InternalMessageInfo

// Instance is the state of an Instance and is the log entry in a multi column logs paxos
type Ins struct {
	InsId *InsId `protobuf:"bytes,1,opt,name=InsId,proto3" json:"InsId,omitempty"`
	// the value proposed on this Instance
	Val *Cmd `protobuf:"bytes,3,opt,name=Val,proto3" json:"Val,omitempty"`
	// at which ballot number the Instance voted it.
	VBal *BallotNum `protobuf:"bytes,5,opt,name=VBal,proto3" json:"VBal,omitempty"`
	// What other instance this instance sees.
	// This view is used to decide the order to apply instances.
	// Intuitively, the more instance one sees, the later it is applied.
	Seen      []int64 `protobuf:"varint,6,rep,packed,name=Seen,proto3" json:"Seen,omitempty"`
	Committed bool    `protobuf:"varint,7,opt,name=Committed,proto3" json:"Committed,omitempty"`
}

func (m *Ins) Reset()         { *m = Ins{} }
func (m *Ins) String() string { return proto.CompactTextString(m) }
func (*Ins) ProtoMessage()    {}
func (*Ins) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fd9fc43023b527a, []int{5}
}
func (m *Ins) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Ins) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Ins.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Ins) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ins.Merge(m, src)
}
func (m *Ins) XXX_Size() int {
	return m.Size()
}
func (m *Ins) XXX_DiscardUnknown() {
	xxx_messageInfo_Ins.DiscardUnknown(m)
}

var xxx_messageInfo_Ins proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("paxoskv.Op", Op_name, Op_value)
	proto.RegisterType((*Request)(nil), "paxoskv.Request")
	proto.RegisterMapType((map[int64]*Ins)(nil), "paxoskv.Request.InstancesEntry")
	proto.RegisterType((*Reply)(nil), "paxoskv.Reply")
	proto.RegisterMapType((map[int64]*Ins)(nil), "paxoskv.Reply.InstancesEntry")
	proto.RegisterType((*BallotNum)(nil), "paxoskv.BallotNum")
	proto.RegisterType((*Cmd)(nil), "paxoskv.Cmd")
	proto.RegisterType((*InsId)(nil), "paxoskv.InsId")
	proto.RegisterType((*Ins)(nil), "paxoskv.Ins")
}

func init() { proto.RegisterFile("paxoskv.proto", fileDescriptor_2fd9fc43023b527a) }

var fileDescriptor_2fd9fc43023b527a = []byte{
	// 570 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x53, 0xcd, 0x6e, 0xd3, 0x40,
	0x10, 0xce, 0x7a, 0xf3, 0xd3, 0x4c, 0x4a, 0x64, 0x8d, 0x10, 0xb2, 0x02, 0x2c, 0x96, 0xa9, 0x2a,
	0xf3, 0x97, 0x8a, 0x14, 0x21, 0x44, 0xc5, 0x81, 0x46, 0x08, 0x4c, 0xab, 0xb4, 0x6c, 0xa5, 0x1c,
	0xb8, 0xb9, 0xf1, 0x52, 0xaa, 0xda, 0x5e, 0x13, 0xdb, 0x15, 0x79, 0x01, 0xce, 0xbc, 0x04, 0x52,
	0x9f, 0x82, 0x73, 0x8f, 0x3d, 0x72, 0xa4, 0xc9, 0x03, 0xf0, 0x0a, 0x68, 0x37, 0x6e, 0x9a, 0x80,
	0x54, 0x6e, 0xdc, 0xbe, 0xd9, 0x6f, 0xe6, 0x9b, 0xf9, 0x3c, 0x63, 0xb8, 0x96, 0xf8, 0x9f, 0x65,
	0x7a, 0x74, 0xdc, 0x4e, 0x86, 0x32, 0x93, 0x58, 0x2b, 0xc2, 0xd6, 0xa3, 0x83, 0xc3, 0xec, 0x63,
	0xbe, 0xdf, 0x1e, 0xc8, 0x68, 0xed, 0x40, 0x1e, 0xc8, 0x35, 0xcd, 0xef, 0xe7, 0x1f, 0x74, 0xa4,
	0x03, 0x8d, 0xa6, 0x75, 0xce, 0x2f, 0x02, 0x35, 0x2e, 0x3e, 0xe5, 0x22, 0xcd, 0xf0, 0x26, 0x18,
	0x3b, 0x89, 0x45, 0x6c, 0xe2, 0x36, 0x3b, 0x8d, 0xf6, 0x85, 0xfe, 0x4e, 0xc2, 0x8d, 0x9d, 0x04,
	0x57, 0x80, 0x6e, 0xfa, 0xa1, 0x55, 0xb1, 0x89, 0xdb, 0xe8, 0xe0, 0x8c, 0xdd, 0xf4, 0xc3, 0x50,
	0x66, 0xbd, 0x3c, 0xe2, 0x8a, 0xc6, 0x1b, 0x50, 0xed, 0xca, 0x30, 0x8f, 0x62, 0x0b, 0x6c, 0xe2,
	0x52, 0x5e, 0x44, 0xf8, 0x02, 0xea, 0x5e, 0x9c, 0x66, 0x7e, 0x3c, 0x10, 0xa9, 0x75, 0xdd, 0xa6,
	0x6e, 0xa3, 0x73, 0x67, 0xa6, 0x51, 0xf4, 0x6f, 0xcf, 0x32, 0x5e, 0xc5, 0xd9, 0x70, 0xc4, 0x2f,
	0x2b, 0x5a, 0x6f, 0xa1, 0xb9, 0x48, 0xa2, 0x09, 0xf4, 0x48, 0x8c, 0xf4, 0xb0, 0x94, 0x2b, 0x88,
	0x0e, 0x54, 0x8e, 0xfd, 0x30, 0x17, 0x96, 0xa1, 0x47, 0x5c, 0x9e, 0xc9, 0x7b, 0x71, 0xca, 0xa7,
	0xd4, 0x73, 0xe3, 0x19, 0x71, 0xbe, 0x13, 0xa8, 0x70, 0x91, 0x84, 0x23, 0x7c, 0x08, 0xb5, 0x6d,
	0x3f, 0xcd, 0xae, 0xb6, 0x75, 0x91, 0x82, 0x1b, 0x7f, 0x5b, 0xb8, 0x3d, 0x67, 0x21, 0x09, 0x47,
	0xff, 0xc9, 0xc0, 0x3d, 0xa8, 0xcf, 0xc6, 0xc3, 0x65, 0x20, 0xbd, 0x42, 0x84, 0xf4, 0xb0, 0x09,
	0x86, 0x17, 0xe8, 0x7a, 0xca, 0x0d, 0x2f, 0x70, 0x1e, 0x00, 0xed, 0x46, 0x81, 0xea, 0xb5, 0x25,
	0x46, 0x16, 0xb5, 0x89, 0x5b, 0xe7, 0x0a, 0x22, 0x42, 0xb9, 0x7f, 0xf8, 0xf4, 0x89, 0x55, 0xd6,
	0xa9, 0x1a, 0x3b, 0xef, 0xa0, 0xe2, 0xc5, 0xa9, 0x17, 0xcc, 0x2d, 0x91, 0x2c, 0x2c, 0xd1, 0x04,
	0xba, 0xbd, 0xd7, 0xd3, 0xdf, 0x8a, 0x72, 0x05, 0x91, 0x01, 0xec, 0x0e, 0x65, 0x22, 0x53, 0x31,
	0xf4, 0x82, 0x62, 0xe5, 0x73, 0x2f, 0xce, 0x37, 0x02, 0xd4, 0x8b, 0x53, 0x5c, 0x29, 0xa4, 0xb5,
	0x60, 0xa3, 0xd3, 0x9c, 0xb7, 0xe6, 0x05, 0xbc, 0xe8, 0xcb, 0x80, 0xf6, 0xfd, 0x50, 0x8f, 0x39,
	0x6f, 0xbf, 0x1b, 0x05, 0x5c, 0x11, 0xb8, 0x0a, 0xe5, 0xfe, 0xd5, 0xcb, 0xd2, 0xbc, 0x32, 0xb7,
	0x27, 0x44, 0x6c, 0x55, 0x6d, 0xaa, 0xcc, 0x29, 0x8c, 0xb7, 0xa0, 0xde, 0x95, 0x51, 0x74, 0x98,
	0x65, 0x22, 0xb0, 0x6a, 0x36, 0x71, 0x97, 0xf8, 0xe5, 0xc3, 0xfd, 0x55, 0x75, 0xf9, 0xb8, 0x04,
	0xe5, 0x9e, 0x94, 0x89, 0x59, 0x42, 0x80, 0xea, 0xcb, 0xc1, 0x40, 0x24, 0x99, 0x49, 0x14, 0x9e,
	0x26, 0x9a, 0x46, 0xe7, 0x0b, 0x81, 0xda, 0xae, 0xea, 0xba, 0xd5, 0xc7, 0xc7, 0xd0, 0x78, 0xe3,
	0xc7, 0x41, 0x28, 0xf4, 0x03, 0x9a, 0x7f, 0x9e, 0x73, 0xab, 0xb9, 0x78, 0x1d, 0x4e, 0x09, 0xef,
	0x02, 0xdd, 0x13, 0x19, 0x2e, 0x58, 0x6b, 0x2d, 0x44, 0xd3, 0xa4, 0xd7, 0xff, 0x4a, 0xda, 0x5c,
	0x3f, 0x3d, 0x67, 0xa5, 0xb3, 0x73, 0x46, 0x4e, 0xc6, 0x8c, 0x9c, 0x8e, 0x19, 0x39, 0x1b, 0x33,
	0xf2, 0x73, 0xcc, 0xc8, 0xd7, 0x09, 0x2b, 0x9d, 0x4c, 0x18, 0x39, 0x9b, 0xb0, 0xd2, 0x8f, 0x09,
	0x2b, 0xbd, 0xaf, 0xb7, 0x37, 0x8a, 0xd2, 0xfd, 0xaa, 0xfe, 0xe5, 0xd7, 0x7f, 0x07, 0x00, 0x00,
	0xff, 0xff, 0xd2, 0x8f, 0xec, 0xb6, 0x3b, 0x04, 0x00, 0x00,
}

func (this *Request) Compare(that interface{}) int {
	if that == nil {
		if this == nil {
			return 0
		}
		return 1
	}

	that1, ok := that.(*Request)
	if !ok {
		that2, ok := that.(Request)
		if ok {
			that1 = &that2
		} else {
			return 1
		}
	}
	if that1 == nil {
		if this == nil {
			return 0
		}
		return 1
	} else if this == nil {
		return -1
	}
	if this.Op != that1.Op {
		if this.Op < that1.Op {
			return -1
		}
		return 1
	}
	if c := this.Bal.Compare(that1.Bal); c != 0 {
		return c
	}
	if this.Column != that1.Column {
		if this.Column < that1.Column {
			return -1
		}
		return 1
	}
	if len(this.Instances) != len(that1.Instances) {
		if len(this.Instances) < len(that1.Instances) {
			return -1
		}
		return 1
	}
	for i := range this.Instances {
		if c := this.Instances[i].Compare(that1.Instances[i]); c != 0 {
			return c
		}
	}
	return 0
}
func (this *Reply) Compare(that interface{}) int {
	if that == nil {
		if this == nil {
			return 0
		}
		return 1
	}

	that1, ok := that.(*Reply)
	if !ok {
		that2, ok := that.(Reply)
		if ok {
			that1 = &that2
		} else {
			return 1
		}
	}
	if that1 == nil {
		if this == nil {
			return 0
		}
		return 1
	} else if this == nil {
		return -1
	}
	if c := this.LastBal.Compare(that1.LastBal); c != 0 {
		return c
	}
	if len(this.Instances) != len(that1.Instances) {
		if len(this.Instances) < len(that1.Instances) {
			return -1
		}
		return 1
	}
	for i := range this.Instances {
		if c := this.Instances[i].Compare(that1.Instances[i]); c != 0 {
			return c
		}
	}
	return 0
}
func (this *BallotNum) Compare(that interface{}) int {
	if that == nil {
		if this == nil {
			return 0
		}
		return 1
	}

	that1, ok := that.(*BallotNum)
	if !ok {
		that2, ok := that.(BallotNum)
		if ok {
			that1 = &that2
		} else {
			return 1
		}
	}
	if that1 == nil {
		if this == nil {
			return 0
		}
		return 1
	} else if this == nil {
		return -1
	}
	if this.N != that1.N {
		if this.N < that1.N {
			return -1
		}
		return 1
	}
	if this.Id != that1.Id {
		if this.Id < that1.Id {
			return -1
		}
		return 1
	}
	return 0
}
func (this *Cmd) Compare(that interface{}) int {
	if that == nil {
		if this == nil {
			return 0
		}
		return 1
	}

	that1, ok := that.(*Cmd)
	if !ok {
		that2, ok := that.(Cmd)
		if ok {
			that1 = &that2
		} else {
			return 1
		}
	}
	if that1 == nil {
		if this == nil {
			return 0
		}
		return 1
	} else if this == nil {
		return -1
	}
	if this.Key != that1.Key {
		if this.Key < that1.Key {
			return -1
		}
		return 1
	}
	if this.Vi64 != that1.Vi64 {
		if this.Vi64 < that1.Vi64 {
			return -1
		}
		return 1
	}
	return 0
}
func (this *InsId) Compare(that interface{}) int {
	if that == nil {
		if this == nil {
			return 0
		}
		return 1
	}

	that1, ok := that.(*InsId)
	if !ok {
		that2, ok := that.(InsId)
		if ok {
			that1 = &that2
		} else {
			return 1
		}
	}
	if that1 == nil {
		if this == nil {
			return 0
		}
		return 1
	} else if this == nil {
		return -1
	}
	if this.Column != that1.Column {
		if this.Column < that1.Column {
			return -1
		}
		return 1
	}
	if this.LSN != that1.LSN {
		if this.LSN < that1.LSN {
			return -1
		}
		return 1
	}
	if this.ProposerId != that1.ProposerId {
		if this.ProposerId < that1.ProposerId {
			return -1
		}
		return 1
	}
	return 0
}
func (this *Ins) Compare(that interface{}) int {
	if that == nil {
		if this == nil {
			return 0
		}
		return 1
	}

	that1, ok := that.(*Ins)
	if !ok {
		that2, ok := that.(Ins)
		if ok {
			that1 = &that2
		} else {
			return 1
		}
	}
	if that1 == nil {
		if this == nil {
			return 0
		}
		return 1
	} else if this == nil {
		return -1
	}
	if c := this.InsId.Compare(that1.InsId); c != 0 {
		return c
	}
	if c := this.Val.Compare(that1.Val); c != 0 {
		return c
	}
	if c := this.VBal.Compare(that1.VBal); c != 0 {
		return c
	}
	if len(this.Seen) != len(that1.Seen) {
		if len(this.Seen) < len(that1.Seen) {
			return -1
		}
		return 1
	}
	for i := range this.Seen {
		if this.Seen[i] != that1.Seen[i] {
			if this.Seen[i] < that1.Seen[i] {
				return -1
			}
			return 1
		}
	}
	if this.Committed != that1.Committed {
		if !this.Committed {
			return -1
		}
		return 1
	}
	return 0
}
func (this *Request) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Request)
	if !ok {
		that2, ok := that.(Request)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Op != that1.Op {
		return false
	}
	if !this.Bal.Equal(that1.Bal) {
		return false
	}
	if this.Column != that1.Column {
		return false
	}
	if len(this.Instances) != len(that1.Instances) {
		return false
	}
	for i := range this.Instances {
		if !this.Instances[i].Equal(that1.Instances[i]) {
			return false
		}
	}
	return true
}
func (this *Reply) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Reply)
	if !ok {
		that2, ok := that.(Reply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LastBal.Equal(that1.LastBal) {
		return false
	}
	if len(this.Instances) != len(that1.Instances) {
		return false
	}
	for i := range this.Instances {
		if !this.Instances[i].Equal(that1.Instances[i]) {
			return false
		}
	}
	return true
}
func (this *BallotNum) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BallotNum)
	if !ok {
		that2, ok := that.(BallotNum)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.N != that1.N {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	return true
}
func (this *Cmd) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Cmd)
	if !ok {
		that2, ok := that.(Cmd)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	if this.Vi64 != that1.Vi64 {
		return false
	}
	return true
}
func (this *InsId) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InsId)
	if !ok {
		that2, ok := that.(InsId)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Column != that1.Column {
		return false
	}
	if this.LSN != that1.LSN {
		return false
	}
	if this.ProposerId != that1.ProposerId {
		return false
	}
	return true
}
func (this *Ins) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Ins)
	if !ok {
		that2, ok := that.(Ins)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.InsId.Equal(that1.InsId) {
		return false
	}
	if !this.Val.Equal(that1.Val) {
		return false
	}
	if !this.VBal.Equal(that1.VBal) {
		return false
	}
	if len(this.Seen) != len(that1.Seen) {
		return false
	}
	for i := range this.Seen {
		if this.Seen[i] != that1.Seen[i] {
			return false
		}
	}
	if this.Committed != that1.Committed {
		return false
	}
	return true
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// PaxosKVClient is the client API for PaxosKV service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type PaxosKVClient interface {
	// paxos API: used internally
	HandlePaxos(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Reply, error)
	Set(ctx context.Context, in *Cmd, opts ...grpc.CallOption) (*Cmd, error)
	Get(ctx context.Context, in *Cmd, opts ...grpc.CallOption) (*Cmd, error)
}

type paxosKVClient struct {
	cc *grpc.ClientConn
}

func NewPaxosKVClient(cc *grpc.ClientConn) PaxosKVClient {
	return &paxosKVClient{cc}
}

func (c *paxosKVClient) HandlePaxos(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := c.cc.Invoke(ctx, "/paxoskv.PaxosKV/HandlePaxos", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paxosKVClient) Set(ctx context.Context, in *Cmd, opts ...grpc.CallOption) (*Cmd, error) {
	out := new(Cmd)
	err := c.cc.Invoke(ctx, "/paxoskv.PaxosKV/Set", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paxosKVClient) Get(ctx context.Context, in *Cmd, opts ...grpc.CallOption) (*Cmd, error) {
	out := new(Cmd)
	err := c.cc.Invoke(ctx, "/paxoskv.PaxosKV/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PaxosKVServer is the server API for PaxosKV service.
type PaxosKVServer interface {
	// paxos API: used internally
	HandlePaxos(context.Context, *Request) (*Reply, error)
	Set(context.Context, *Cmd) (*Cmd, error)
	Get(context.Context, *Cmd) (*Cmd, error)
}

// UnimplementedPaxosKVServer can be embedded to have forward compatible implementations.
type UnimplementedPaxosKVServer struct {
}

func (*UnimplementedPaxosKVServer) HandlePaxos(ctx context.Context, req *Request) (*Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HandlePaxos not implemented")
}
func (*UnimplementedPaxosKVServer) Set(ctx context.Context, req *Cmd) (*Cmd, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Set not implemented")
}
func (*UnimplementedPaxosKVServer) Get(ctx context.Context, req *Cmd) (*Cmd, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}

func RegisterPaxosKVServer(s *grpc.Server, srv PaxosKVServer) {
	s.RegisterService(&_PaxosKV_serviceDesc, srv)
}

func _PaxosKV_HandlePaxos_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaxosKVServer).HandlePaxos(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/paxoskv.PaxosKV/HandlePaxos",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaxosKVServer).HandlePaxos(ctx, req.(*Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaxosKV_Set_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Cmd)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaxosKVServer).Set(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/paxoskv.PaxosKV/Set",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaxosKVServer).Set(ctx, req.(*Cmd))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaxosKV_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Cmd)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaxosKVServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/paxoskv.PaxosKV/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaxosKVServer).Get(ctx, req.(*Cmd))
	}
	return interceptor(ctx, in, info, handler)
}

var _PaxosKV_serviceDesc = grpc.ServiceDesc{
	ServiceName: "paxoskv.PaxosKV",
	HandlerType: (*PaxosKVServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "HandlePaxos",
			Handler:    _PaxosKV_HandlePaxos_Handler,
		},
		{
			MethodName: "Set",
			Handler:    _PaxosKV_Set_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _PaxosKV_Get_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "paxoskv.proto",
}

func (m *Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Instances) > 0 {
		for k := range m.Instances {
			v := m.Instances[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPaxoskv(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintPaxoskv(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintPaxoskv(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa2
		}
	}
	if m.Column != 0 {
		i = encodeVarintPaxoskv(dAtA, i, uint64(m.Column))
		i--
		dAtA[i] = 0x50
	}
	if m.Bal != nil {
		{
			size, err := m.Bal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPaxoskv(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Op != 0 {
		i = encodeVarintPaxoskv(dAtA, i, uint64(m.Op))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Reply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Reply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Reply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Instances) > 0 {
		for k := range m.Instances {
			v := m.Instances[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPaxoskv(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintPaxoskv(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintPaxoskv(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa2
		}
	}
	if m.LastBal != nil {
		{
			size, err := m.LastBal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPaxoskv(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}

func (m *BallotNum) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BallotNum) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BallotNum) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		i = encodeVarintPaxoskv(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x10
	}
	if m.N != 0 {
		i = encodeVarintPaxoskv(dAtA, i, uint64(m.N))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Cmd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cmd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Cmd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Vi64 != 0 {
		i = encodeVarintPaxoskv(dAtA, i, uint64(m.Vi64))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintPaxoskv(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}

func (m *InsId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InsId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InsId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ProposerId != 0 {
		i = encodeVarintPaxoskv(dAtA, i, uint64(m.ProposerId))
		i--
		dAtA[i] = 0x50
	}
	if m.LSN != 0 {
		i = encodeVarintPaxoskv(dAtA, i, uint64(m.LSN))
		i--
		dAtA[i] = 0x28
	}
	if m.Column != 0 {
		i = encodeVarintPaxoskv(dAtA, i, uint64(m.Column))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Ins) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ins) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Ins) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Committed {
		i--
		if m.Committed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.Seen) > 0 {
		dAtA6 := make([]byte, len(m.Seen)*10)
		var j5 int
		for _, num1 := range m.Seen {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintPaxoskv(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0x32
	}
	if m.VBal != nil {
		{
			size, err := m.VBal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPaxoskv(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Val != nil {
		{
			size, err := m.Val.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPaxoskv(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.InsId != nil {
		{
			size, err := m.InsId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPaxoskv(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintPaxoskv(dAtA []byte, offset int, v uint64) int {
	offset -= sovPaxoskv(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Request) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovPaxoskv(uint64(m.Op))
	}
	if m.Bal != nil {
		l = m.Bal.Size()
		n += 1 + l + sovPaxoskv(uint64(l))
	}
	if m.Column != 0 {
		n += 1 + sovPaxoskv(uint64(m.Column))
	}
	if len(m.Instances) > 0 {
		for k, v := range m.Instances {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPaxoskv(uint64(l))
			}
			mapEntrySize := 1 + sovPaxoskv(uint64(k)) + l
			n += mapEntrySize + 2 + sovPaxoskv(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Reply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LastBal != nil {
		l = m.LastBal.Size()
		n += 1 + l + sovPaxoskv(uint64(l))
	}
	if len(m.Instances) > 0 {
		for k, v := range m.Instances {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPaxoskv(uint64(l))
			}
			mapEntrySize := 1 + sovPaxoskv(uint64(k)) + l
			n += mapEntrySize + 2 + sovPaxoskv(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *BallotNum) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.N != 0 {
		n += 1 + sovPaxoskv(uint64(m.N))
	}
	if m.Id != 0 {
		n += 1 + sovPaxoskv(uint64(m.Id))
	}
	return n
}

func (m *Cmd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovPaxoskv(uint64(l))
	}
	if m.Vi64 != 0 {
		n += 1 + sovPaxoskv(uint64(m.Vi64))
	}
	return n
}

func (m *InsId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Column != 0 {
		n += 1 + sovPaxoskv(uint64(m.Column))
	}
	if m.LSN != 0 {
		n += 1 + sovPaxoskv(uint64(m.LSN))
	}
	if m.ProposerId != 0 {
		n += 1 + sovPaxoskv(uint64(m.ProposerId))
	}
	return n
}

func (m *Ins) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InsId != nil {
		l = m.InsId.Size()
		n += 1 + l + sovPaxoskv(uint64(l))
	}
	if m.Val != nil {
		l = m.Val.Size()
		n += 1 + l + sovPaxoskv(uint64(l))
	}
	if m.VBal != nil {
		l = m.VBal.Size()
		n += 1 + l + sovPaxoskv(uint64(l))
	}
	if len(m.Seen) > 0 {
		l = 0
		for _, e := range m.Seen {
			l += sovPaxoskv(uint64(e))
		}
		n += 1 + sovPaxoskv(uint64(l)) + l
	}
	if m.Committed {
		n += 2
	}
	return n
}

func sovPaxoskv(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPaxoskv(x uint64) (n int) {
	return sovPaxoskv(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPaxoskv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaxoskv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= Op(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaxoskv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPaxoskv
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPaxoskv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Bal == nil {
				m.Bal = &BallotNum{}
			}
			if err := m.Bal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Column", wireType)
			}
			m.Column = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaxoskv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Column |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaxoskv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPaxoskv
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPaxoskv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Instances == nil {
				m.Instances = make(map[int64]*Ins)
			}
			var mapkey int64
			var mapvalue *Ins
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPaxoskv
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPaxoskv
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPaxoskv
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPaxoskv
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPaxoskv
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Ins{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPaxoskv(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPaxoskv
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Instances[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPaxoskv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPaxoskv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Reply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPaxoskv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Reply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Reply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastBal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaxoskv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPaxoskv
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPaxoskv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastBal == nil {
				m.LastBal = &BallotNum{}
			}
			if err := m.LastBal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaxoskv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPaxoskv
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPaxoskv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Instances == nil {
				m.Instances = make(map[int64]*Ins)
			}
			var mapkey int64
			var mapvalue *Ins
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPaxoskv
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPaxoskv
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPaxoskv
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPaxoskv
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPaxoskv
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Ins{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPaxoskv(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPaxoskv
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Instances[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPaxoskv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPaxoskv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BallotNum) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPaxoskv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BallotNum: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BallotNum: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field N", wireType)
			}
			m.N = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaxoskv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.N |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaxoskv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPaxoskv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPaxoskv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPaxoskv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaxoskv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPaxoskv
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPaxoskv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vi64", wireType)
			}
			m.Vi64 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaxoskv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vi64 |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPaxoskv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPaxoskv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InsId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPaxoskv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InsId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InsId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Column", wireType)
			}
			m.Column = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaxoskv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Column |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LSN", wireType)
			}
			m.LSN = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaxoskv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LSN |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposerId", wireType)
			}
			m.ProposerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaxoskv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPaxoskv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPaxoskv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ins) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPaxoskv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ins: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ins: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaxoskv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPaxoskv
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPaxoskv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InsId == nil {
				m.InsId = &InsId{}
			}
			if err := m.InsId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaxoskv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPaxoskv
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPaxoskv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Val == nil {
				m.Val = &Cmd{}
			}
			if err := m.Val.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VBal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaxoskv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPaxoskv
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPaxoskv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VBal == nil {
				m.VBal = &BallotNum{}
			}
			if err := m.VBal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPaxoskv
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Seen = append(m.Seen, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPaxoskv
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPaxoskv
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPaxoskv
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Seen) == 0 {
					m.Seen = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPaxoskv
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Seen = append(m.Seen, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Seen", wireType)
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Committed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaxoskv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Committed = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPaxoskv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPaxoskv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPaxoskv(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPaxoskv
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPaxoskv
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPaxoskv
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPaxoskv
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPaxoskv
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPaxoskv
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPaxoskv        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPaxoskv          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPaxoskv = fmt.Errorf("proto: unexpected end of group")
)
