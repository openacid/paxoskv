// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: paxoskv.proto

package paxoskv

import (
	context "context"
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Op int32

const (
	Op_Noop    Op = 0
	Op_Prepare Op = 1
	Op_Accept  Op = 2
	Op_Commit  Op = 3
)

var Op_name = map[int32]string{
	0: "Noop",
	1: "Prepare",
	2: "Accept",
	3: "Commit",
}

var Op_value = map[string]int32{
	"Noop":    0,
	"Prepare": 1,
	"Accept":  2,
	"Commit":  3,
}

func (x Op) String() string {
	return proto.EnumName(Op_name, int32(x))
}

func (Op) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2fd9fc43023b527a, []int{0}
}

type Request struct {
	Ops    []Op       `protobuf:"varint,1,rep,packed,name=Ops,proto3,enum=paxoskv.Op" json:"Ops,omitempty"`
	Bal    *BallotNum `protobuf:"bytes,5,opt,name=Bal,proto3" json:"Bal,omitempty"`
	Column int64      `protobuf:"varint,10,opt,name=Column,proto3" json:"Column,omitempty"`
	// from what paxos instance it runs on
	Instances map[int64]*Instance `protobuf:"bytes,20,rep,name=Instances,proto3" json:"Instances,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Request) Reset()         { *m = Request{} }
func (m *Request) String() string { return proto.CompactTextString(m) }
func (*Request) ProtoMessage()    {}
func (*Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fd9fc43023b527a, []int{0}
}
func (m *Request) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request.Merge(m, src)
}
func (m *Request) XXX_Size() int {
	return m.Size()
}
func (m *Request) XXX_DiscardUnknown() {
	xxx_messageInfo_Request.DiscardUnknown(m)
}

var xxx_messageInfo_Request proto.InternalMessageInfo

type Reply struct {
	LastBal *BallotNum `protobuf:"bytes,5,opt,name=LastBal,proto3" json:"LastBal,omitempty"`
	// from what paxos instance it runs on
	Instances map[int64]*Instance `protobuf:"bytes,20,rep,name=Instances,proto3" json:"Instances,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Reply) Reset()         { *m = Reply{} }
func (m *Reply) String() string { return proto.CompactTextString(m) }
func (*Reply) ProtoMessage()    {}
func (*Reply) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fd9fc43023b527a, []int{1}
}
func (m *Reply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Reply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Reply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Reply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Reply.Merge(m, src)
}
func (m *Reply) XXX_Size() int {
	return m.Size()
}
func (m *Reply) XXX_DiscardUnknown() {
	xxx_messageInfo_Reply.DiscardUnknown(m)
}

var xxx_messageInfo_Reply proto.InternalMessageInfo

// BallotNum is the ballot number in paxos. It consists of a monotonically
// incremental number and a universally unique ProposerId.
type BallotNum struct {
	N  int64 `protobuf:"varint,1,opt,name=N,proto3" json:"N,omitempty"`
	Id int64 `protobuf:"varint,2,opt,name=Id,proto3" json:"Id,omitempty"`
}

func (m *BallotNum) Reset()         { *m = BallotNum{} }
func (m *BallotNum) String() string { return proto.CompactTextString(m) }
func (*BallotNum) ProtoMessage()    {}
func (*BallotNum) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fd9fc43023b527a, []int{2}
}
func (m *BallotNum) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BallotNum) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BallotNum.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BallotNum) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BallotNum.Merge(m, src)
}
func (m *BallotNum) XXX_Size() int {
	return m.Size()
}
func (m *BallotNum) XXX_DiscardUnknown() {
	xxx_messageInfo_BallotNum.DiscardUnknown(m)
}

var xxx_messageInfo_BallotNum proto.InternalMessageInfo

// Cmd is the value in this paxos impl, which is a command to set a key-value
// record.
// In this demo it is just string key and a int64 value.
type Cmd struct {
	ValueId *ValueId `protobuf:"bytes,5,opt,name=ValueId,proto3" json:"ValueId,omitempty"`
	Key     string   `protobuf:"bytes,3,opt,name=Key,proto3" json:"Key,omitempty"`
	Vi64    int64    `protobuf:"varint,4,opt,name=Vi64,proto3" json:"Vi64,omitempty"`
}

func (m *Cmd) Reset()         { *m = Cmd{} }
func (m *Cmd) String() string { return proto.CompactTextString(m) }
func (*Cmd) ProtoMessage()    {}
func (*Cmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fd9fc43023b527a, []int{3}
}
func (m *Cmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Cmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Cmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Cmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cmd.Merge(m, src)
}
func (m *Cmd) XXX_Size() int {
	return m.Size()
}
func (m *Cmd) XXX_DiscardUnknown() {
	xxx_messageInfo_Cmd.DiscardUnknown(m)
}

var xxx_messageInfo_Cmd proto.InternalMessageInfo

type ValueId struct {
	Column int64 `protobuf:"varint,1,opt,name=Column,proto3" json:"Column,omitempty"`
	LSN    int64 `protobuf:"varint,5,opt,name=LSN,proto3" json:"LSN,omitempty"`
	// The ballot.N of the proposer created this Value
	ProposerN int64 `protobuf:"varint,10,opt,name=ProposerN,proto3" json:"ProposerN,omitempty"`
}

func (m *ValueId) Reset()         { *m = ValueId{} }
func (m *ValueId) String() string { return proto.CompactTextString(m) }
func (*ValueId) ProtoMessage()    {}
func (*ValueId) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fd9fc43023b527a, []int{4}
}
func (m *ValueId) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValueId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValueId.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValueId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValueId.Merge(m, src)
}
func (m *ValueId) XXX_Size() int {
	return m.Size()
}
func (m *ValueId) XXX_DiscardUnknown() {
	xxx_messageInfo_ValueId.DiscardUnknown(m)
}

var xxx_messageInfo_ValueId proto.InternalMessageInfo

// Instance is the state of an Instance and is the log entry in a multi
// paxos logs
type Instance struct {
	// the value voted by this Instance
	Val *Cmd `protobuf:"bytes,3,opt,name=Val,proto3" json:"Val,omitempty"`
	// at which ballot number the Instance voted it.
	VBal      *BallotNum `protobuf:"bytes,5,opt,name=VBal,proto3" json:"VBal,omitempty"`
	Seen      []int64    `protobuf:"varint,6,rep,packed,name=Seen,proto3" json:"Seen,omitempty"`
	Committed bool       `protobuf:"varint,7,opt,name=Committed,proto3" json:"Committed,omitempty"`
}

func (m *Instance) Reset()         { *m = Instance{} }
func (m *Instance) String() string { return proto.CompactTextString(m) }
func (*Instance) ProtoMessage()    {}
func (*Instance) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fd9fc43023b527a, []int{5}
}
func (m *Instance) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Instance) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Instance.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Instance) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Instance.Merge(m, src)
}
func (m *Instance) XXX_Size() int {
	return m.Size()
}
func (m *Instance) XXX_DiscardUnknown() {
	xxx_messageInfo_Instance.DiscardUnknown(m)
}

var xxx_messageInfo_Instance proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("paxoskv.Op", Op_name, Op_value)
	proto.RegisterType((*Request)(nil), "paxoskv.Request")
	proto.RegisterMapType((map[int64]*Instance)(nil), "paxoskv.Request.InstancesEntry")
	proto.RegisterType((*Reply)(nil), "paxoskv.Reply")
	proto.RegisterMapType((map[int64]*Instance)(nil), "paxoskv.Reply.InstancesEntry")
	proto.RegisterType((*BallotNum)(nil), "paxoskv.BallotNum")
	proto.RegisterType((*Cmd)(nil), "paxoskv.Cmd")
	proto.RegisterType((*ValueId)(nil), "paxoskv.ValueId")
	proto.RegisterType((*Instance)(nil), "paxoskv.Instance")
}

func init() { proto.RegisterFile("paxoskv.proto", fileDescriptor_2fd9fc43023b527a) }

var fileDescriptor_2fd9fc43023b527a = []byte{
	// 579 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x54, 0x4d, 0x6f, 0xd3, 0x40,
	0x10, 0xcd, 0x66, 0xd3, 0xb8, 0x99, 0x94, 0xc8, 0x8c, 0x10, 0xb2, 0x22, 0x6a, 0x2c, 0x83, 0xc0,
	0x54, 0x90, 0x8a, 0x14, 0x21, 0x44, 0xc5, 0x81, 0x46, 0x08, 0xa2, 0x56, 0x4e, 0xd9, 0x4a, 0x41,
	0xe2, 0xe6, 0xc6, 0x4b, 0xa9, 0x6a, 0x7b, 0x8d, 0x3f, 0x2a, 0x72, 0x47, 0x9c, 0xf9, 0x19, 0xfd,
	0x1f, 0x5c, 0x7a, 0xec, 0x91, 0x23, 0x4d, 0xfe, 0x03, 0x67, 0xb4, 0x1b, 0xc7, 0x6d, 0x40, 0x2a,
	0x37, 0x6e, 0x6f, 0xe6, 0xcd, 0xc7, 0x7b, 0xda, 0xd1, 0xc2, 0xb5, 0xd8, 0xfb, 0x2c, 0xd2, 0xa3,
	0xe3, 0x4e, 0x9c, 0x88, 0x4c, 0xa0, 0x56, 0x84, 0xed, 0x47, 0x07, 0x87, 0xd9, 0xc7, 0x7c, 0xbf,
	0x33, 0x12, 0xe1, 0xfa, 0x81, 0x38, 0x10, 0xeb, 0x8a, 0xdf, 0xcf, 0x3f, 0xa8, 0x48, 0x05, 0x0a,
	0xcd, 0xfa, 0xec, 0x5f, 0x04, 0x34, 0xc6, 0x3f, 0xe5, 0x3c, 0xcd, 0x70, 0x15, 0xe8, 0x20, 0x4e,
	0x0d, 0x62, 0x51, 0xa7, 0xd5, 0x6d, 0x76, 0xe6, 0x0b, 0x06, 0x31, 0x93, 0x79, 0xbc, 0x0b, 0x74,
	0xcb, 0x0b, 0x8c, 0x25, 0x8b, 0x38, 0xcd, 0x2e, 0x96, 0xf4, 0x96, 0x17, 0x04, 0x22, 0x73, 0xf3,
	0x90, 0x49, 0x1a, 0x6f, 0x42, 0xbd, 0x27, 0x82, 0x3c, 0x8c, 0x0c, 0xb0, 0x88, 0x43, 0x59, 0x11,
	0xe1, 0x0b, 0x68, 0xf4, 0xa3, 0x34, 0xf3, 0xa2, 0x11, 0x4f, 0x8d, 0x1b, 0x16, 0x75, 0x9a, 0xdd,
	0xdb, 0xe5, 0x8c, 0x42, 0x41, 0xa7, 0xac, 0x78, 0x15, 0x65, 0xc9, 0x98, 0x5d, 0x74, 0xb4, 0x07,
	0xd0, 0x5a, 0x24, 0x51, 0x07, 0x7a, 0xc4, 0xc7, 0x06, 0x51, 0x5b, 0x24, 0xc4, 0xfb, 0xb0, 0x74,
	0xec, 0x05, 0x39, 0x37, 0xaa, 0x4a, 0xe2, 0xf5, 0x72, 0xfc, 0xbc, 0x93, 0xcd, 0xf8, 0xe7, 0xd5,
	0x67, 0xc4, 0xfe, 0x4e, 0x60, 0x89, 0xf1, 0x38, 0x18, 0xe3, 0x43, 0xd0, 0x76, 0xbc, 0x34, 0xbb,
	0xda, 0xdb, 0xbc, 0x04, 0x37, 0xff, 0xf6, 0xb1, 0x7a, 0xc9, 0x47, 0x1c, 0x8c, 0xff, 0xa7, 0x8b,
	0x07, 0xd0, 0x28, 0x35, 0xe2, 0x0a, 0x10, 0xb7, 0x98, 0x44, 0x5c, 0x6c, 0x41, 0xb5, 0xef, 0xab,
	0x21, 0x94, 0x55, 0xfb, 0xbe, 0xfd, 0x0e, 0x68, 0x2f, 0xf4, 0x71, 0x0d, 0xb4, 0xa1, 0x6c, 0xef,
	0xfb, 0x85, 0x5b, 0xbd, 0x5c, 0x50, 0xe4, 0xd9, 0xbc, 0x40, 0x8a, 0xdb, 0xe6, 0x63, 0x83, 0x5a,
	0xc4, 0x69, 0x30, 0x09, 0x11, 0xa1, 0x36, 0x3c, 0x7c, 0xfa, 0xc4, 0xa8, 0xa9, 0xb1, 0x0a, 0xdb,
	0x6f, 0xcb, 0x89, 0x97, 0x1e, 0x9f, 0x2c, 0x3c, 0xbe, 0x0e, 0x74, 0x67, 0xcf, 0x55, 0x0b, 0x29,
	0x93, 0x10, 0x6f, 0x41, 0x63, 0x37, 0x11, 0xb1, 0x48, 0x79, 0xe2, 0x16, 0x97, 0x72, 0x91, 0xb0,
	0xbf, 0x10, 0x58, 0x9e, 0xdb, 0x45, 0x13, 0xe8, 0xd0, 0x0b, 0x94, 0x8a, 0x66, 0x77, 0xa5, 0x54,
	0xdb, 0x0b, 0x7d, 0x26, 0x09, 0xbc, 0x07, 0xb5, 0xe1, 0xd5, 0x8f, 0xa7, 0x78, 0xa9, 0x7d, 0x8f,
	0xf3, 0xc8, 0xa8, 0x5b, 0x54, 0x6a, 0x97, 0x58, 0xca, 0xe8, 0x89, 0x30, 0x3c, 0xcc, 0x32, 0xee,
	0x1b, 0x9a, 0x45, 0x9c, 0x65, 0x76, 0x91, 0x58, 0xdb, 0x80, 0xea, 0x20, 0xc6, 0x65, 0xa8, 0xb9,
	0x42, 0xc4, 0x7a, 0x05, 0x9b, 0xa0, 0xed, 0x26, 0x3c, 0xf6, 0x12, 0xae, 0x13, 0x04, 0xa8, 0xbf,
	0x1c, 0x8d, 0x78, 0x9c, 0xe9, 0x55, 0x89, 0x67, 0x5d, 0x3a, 0xed, 0x7e, 0x25, 0xa0, 0xed, 0x4a,
	0x09, 0xdb, 0x43, 0x7c, 0x0c, 0xcd, 0x37, 0x5e, 0xe4, 0x07, 0x5c, 0x25, 0x50, 0xff, 0xf3, 0xe0,
	0xdb, 0xad, 0xc5, 0xd3, 0xb1, 0x2b, 0x78, 0x07, 0xe8, 0x1e, 0xcf, 0x70, 0xc1, 0x67, 0x7b, 0x21,
	0x9a, 0x15, 0xbd, 0xfe, 0x57, 0xd1, 0xd6, 0xc6, 0xe9, 0xb9, 0x59, 0x39, 0x3b, 0x37, 0xc9, 0xc9,
	0xc4, 0x24, 0xa7, 0x13, 0x93, 0x9c, 0x4d, 0x4c, 0xf2, 0x73, 0x62, 0x92, 0x6f, 0x53, 0xb3, 0x72,
	0x32, 0x35, 0xc9, 0xd9, 0xd4, 0xac, 0xfc, 0x98, 0x9a, 0x95, 0xf7, 0x8d, 0xce, 0x66, 0xd1, 0xba,
	0x5f, 0x57, 0xdf, 0xc2, 0xc6, 0xef, 0x00, 0x00, 0x00, 0xff, 0xff, 0xe2, 0x55, 0x1a, 0x1c, 0x5f,
	0x04, 0x00, 0x00,
}

func (this *Request) Compare(that interface{}) int {
	if that == nil {
		if this == nil {
			return 0
		}
		return 1
	}

	that1, ok := that.(*Request)
	if !ok {
		that2, ok := that.(Request)
		if ok {
			that1 = &that2
		} else {
			return 1
		}
	}
	if that1 == nil {
		if this == nil {
			return 0
		}
		return 1
	} else if this == nil {
		return -1
	}
	if len(this.Ops) != len(that1.Ops) {
		if len(this.Ops) < len(that1.Ops) {
			return -1
		}
		return 1
	}
	for i := range this.Ops {
		if this.Ops[i] != that1.Ops[i] {
			if this.Ops[i] < that1.Ops[i] {
				return -1
			}
			return 1
		}
	}
	if c := this.Bal.Compare(that1.Bal); c != 0 {
		return c
	}
	if this.Column != that1.Column {
		if this.Column < that1.Column {
			return -1
		}
		return 1
	}
	if len(this.Instances) != len(that1.Instances) {
		if len(this.Instances) < len(that1.Instances) {
			return -1
		}
		return 1
	}
	for i := range this.Instances {
		if c := this.Instances[i].Compare(that1.Instances[i]); c != 0 {
			return c
		}
	}
	return 0
}
func (this *Reply) Compare(that interface{}) int {
	if that == nil {
		if this == nil {
			return 0
		}
		return 1
	}

	that1, ok := that.(*Reply)
	if !ok {
		that2, ok := that.(Reply)
		if ok {
			that1 = &that2
		} else {
			return 1
		}
	}
	if that1 == nil {
		if this == nil {
			return 0
		}
		return 1
	} else if this == nil {
		return -1
	}
	if c := this.LastBal.Compare(that1.LastBal); c != 0 {
		return c
	}
	if len(this.Instances) != len(that1.Instances) {
		if len(this.Instances) < len(that1.Instances) {
			return -1
		}
		return 1
	}
	for i := range this.Instances {
		if c := this.Instances[i].Compare(that1.Instances[i]); c != 0 {
			return c
		}
	}
	return 0
}
func (this *BallotNum) Compare(that interface{}) int {
	if that == nil {
		if this == nil {
			return 0
		}
		return 1
	}

	that1, ok := that.(*BallotNum)
	if !ok {
		that2, ok := that.(BallotNum)
		if ok {
			that1 = &that2
		} else {
			return 1
		}
	}
	if that1 == nil {
		if this == nil {
			return 0
		}
		return 1
	} else if this == nil {
		return -1
	}
	if this.N != that1.N {
		if this.N < that1.N {
			return -1
		}
		return 1
	}
	if this.Id != that1.Id {
		if this.Id < that1.Id {
			return -1
		}
		return 1
	}
	return 0
}
func (this *Cmd) Compare(that interface{}) int {
	if that == nil {
		if this == nil {
			return 0
		}
		return 1
	}

	that1, ok := that.(*Cmd)
	if !ok {
		that2, ok := that.(Cmd)
		if ok {
			that1 = &that2
		} else {
			return 1
		}
	}
	if that1 == nil {
		if this == nil {
			return 0
		}
		return 1
	} else if this == nil {
		return -1
	}
	if c := this.ValueId.Compare(that1.ValueId); c != 0 {
		return c
	}
	if this.Key != that1.Key {
		if this.Key < that1.Key {
			return -1
		}
		return 1
	}
	if this.Vi64 != that1.Vi64 {
		if this.Vi64 < that1.Vi64 {
			return -1
		}
		return 1
	}
	return 0
}
func (this *ValueId) Compare(that interface{}) int {
	if that == nil {
		if this == nil {
			return 0
		}
		return 1
	}

	that1, ok := that.(*ValueId)
	if !ok {
		that2, ok := that.(ValueId)
		if ok {
			that1 = &that2
		} else {
			return 1
		}
	}
	if that1 == nil {
		if this == nil {
			return 0
		}
		return 1
	} else if this == nil {
		return -1
	}
	if this.Column != that1.Column {
		if this.Column < that1.Column {
			return -1
		}
		return 1
	}
	if this.LSN != that1.LSN {
		if this.LSN < that1.LSN {
			return -1
		}
		return 1
	}
	if this.ProposerN != that1.ProposerN {
		if this.ProposerN < that1.ProposerN {
			return -1
		}
		return 1
	}
	return 0
}
func (this *Instance) Compare(that interface{}) int {
	if that == nil {
		if this == nil {
			return 0
		}
		return 1
	}

	that1, ok := that.(*Instance)
	if !ok {
		that2, ok := that.(Instance)
		if ok {
			that1 = &that2
		} else {
			return 1
		}
	}
	if that1 == nil {
		if this == nil {
			return 0
		}
		return 1
	} else if this == nil {
		return -1
	}
	if c := this.Val.Compare(that1.Val); c != 0 {
		return c
	}
	if c := this.VBal.Compare(that1.VBal); c != 0 {
		return c
	}
	if len(this.Seen) != len(that1.Seen) {
		if len(this.Seen) < len(that1.Seen) {
			return -1
		}
		return 1
	}
	for i := range this.Seen {
		if this.Seen[i] != that1.Seen[i] {
			if this.Seen[i] < that1.Seen[i] {
				return -1
			}
			return 1
		}
	}
	if this.Committed != that1.Committed {
		if !this.Committed {
			return -1
		}
		return 1
	}
	return 0
}
func (this *Request) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Request)
	if !ok {
		that2, ok := that.(Request)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Ops) != len(that1.Ops) {
		return false
	}
	for i := range this.Ops {
		if this.Ops[i] != that1.Ops[i] {
			return false
		}
	}
	if !this.Bal.Equal(that1.Bal) {
		return false
	}
	if this.Column != that1.Column {
		return false
	}
	if len(this.Instances) != len(that1.Instances) {
		return false
	}
	for i := range this.Instances {
		if !this.Instances[i].Equal(that1.Instances[i]) {
			return false
		}
	}
	return true
}
func (this *Reply) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Reply)
	if !ok {
		that2, ok := that.(Reply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LastBal.Equal(that1.LastBal) {
		return false
	}
	if len(this.Instances) != len(that1.Instances) {
		return false
	}
	for i := range this.Instances {
		if !this.Instances[i].Equal(that1.Instances[i]) {
			return false
		}
	}
	return true
}
func (this *BallotNum) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BallotNum)
	if !ok {
		that2, ok := that.(BallotNum)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.N != that1.N {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	return true
}
func (this *Cmd) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Cmd)
	if !ok {
		that2, ok := that.(Cmd)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ValueId.Equal(that1.ValueId) {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	if this.Vi64 != that1.Vi64 {
		return false
	}
	return true
}
func (this *ValueId) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ValueId)
	if !ok {
		that2, ok := that.(ValueId)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Column != that1.Column {
		return false
	}
	if this.LSN != that1.LSN {
		return false
	}
	if this.ProposerN != that1.ProposerN {
		return false
	}
	return true
}
func (this *Instance) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Instance)
	if !ok {
		that2, ok := that.(Instance)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Val.Equal(that1.Val) {
		return false
	}
	if !this.VBal.Equal(that1.VBal) {
		return false
	}
	if len(this.Seen) != len(that1.Seen) {
		return false
	}
	for i := range this.Seen {
		if this.Seen[i] != that1.Seen[i] {
			return false
		}
	}
	if this.Committed != that1.Committed {
		return false
	}
	return true
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// PaxosKVClient is the client API for PaxosKV service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type PaxosKVClient interface {
	// paxos API: used internally
	HandlePaxos(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Reply, error)
	Set(ctx context.Context, in *Cmd, opts ...grpc.CallOption) (*Cmd, error)
	Get(ctx context.Context, in *Cmd, opts ...grpc.CallOption) (*Cmd, error)
}

type paxosKVClient struct {
	cc *grpc.ClientConn
}

func NewPaxosKVClient(cc *grpc.ClientConn) PaxosKVClient {
	return &paxosKVClient{cc}
}

func (c *paxosKVClient) HandlePaxos(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := c.cc.Invoke(ctx, "/paxoskv.PaxosKV/HandlePaxos", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paxosKVClient) Set(ctx context.Context, in *Cmd, opts ...grpc.CallOption) (*Cmd, error) {
	out := new(Cmd)
	err := c.cc.Invoke(ctx, "/paxoskv.PaxosKV/Set", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paxosKVClient) Get(ctx context.Context, in *Cmd, opts ...grpc.CallOption) (*Cmd, error) {
	out := new(Cmd)
	err := c.cc.Invoke(ctx, "/paxoskv.PaxosKV/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PaxosKVServer is the server API for PaxosKV service.
type PaxosKVServer interface {
	// paxos API: used internally
	HandlePaxos(context.Context, *Request) (*Reply, error)
	Set(context.Context, *Cmd) (*Cmd, error)
	Get(context.Context, *Cmd) (*Cmd, error)
}

// UnimplementedPaxosKVServer can be embedded to have forward compatible implementations.
type UnimplementedPaxosKVServer struct {
}

func (*UnimplementedPaxosKVServer) HandlePaxos(ctx context.Context, req *Request) (*Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HandlePaxos not implemented")
}
func (*UnimplementedPaxosKVServer) Set(ctx context.Context, req *Cmd) (*Cmd, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Set not implemented")
}
func (*UnimplementedPaxosKVServer) Get(ctx context.Context, req *Cmd) (*Cmd, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}

func RegisterPaxosKVServer(s *grpc.Server, srv PaxosKVServer) {
	s.RegisterService(&_PaxosKV_serviceDesc, srv)
}

func _PaxosKV_HandlePaxos_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaxosKVServer).HandlePaxos(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/paxoskv.PaxosKV/HandlePaxos",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaxosKVServer).HandlePaxos(ctx, req.(*Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaxosKV_Set_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Cmd)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaxosKVServer).Set(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/paxoskv.PaxosKV/Set",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaxosKVServer).Set(ctx, req.(*Cmd))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaxosKV_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Cmd)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaxosKVServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/paxoskv.PaxosKV/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaxosKVServer).Get(ctx, req.(*Cmd))
	}
	return interceptor(ctx, in, info, handler)
}

var _PaxosKV_serviceDesc = grpc.ServiceDesc{
	ServiceName: "paxoskv.PaxosKV",
	HandlerType: (*PaxosKVServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "HandlePaxos",
			Handler:    _PaxosKV_HandlePaxos_Handler,
		},
		{
			MethodName: "Set",
			Handler:    _PaxosKV_Set_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _PaxosKV_Get_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "paxoskv.proto",
}

func (m *Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Instances) > 0 {
		for k := range m.Instances {
			v := m.Instances[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPaxoskv(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintPaxoskv(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintPaxoskv(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa2
		}
	}
	if m.Column != 0 {
		i = encodeVarintPaxoskv(dAtA, i, uint64(m.Column))
		i--
		dAtA[i] = 0x50
	}
	if m.Bal != nil {
		{
			size, err := m.Bal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPaxoskv(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Ops) > 0 {
		dAtA4 := make([]byte, len(m.Ops)*10)
		var j3 int
		for _, num := range m.Ops {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintPaxoskv(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Reply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Reply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Reply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Instances) > 0 {
		for k := range m.Instances {
			v := m.Instances[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPaxoskv(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintPaxoskv(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintPaxoskv(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa2
		}
	}
	if m.LastBal != nil {
		{
			size, err := m.LastBal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPaxoskv(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}

func (m *BallotNum) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BallotNum) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BallotNum) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		i = encodeVarintPaxoskv(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x10
	}
	if m.N != 0 {
		i = encodeVarintPaxoskv(dAtA, i, uint64(m.N))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Cmd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cmd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Cmd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ValueId != nil {
		{
			size, err := m.ValueId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPaxoskv(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Vi64 != 0 {
		i = encodeVarintPaxoskv(dAtA, i, uint64(m.Vi64))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintPaxoskv(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}

func (m *ValueId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValueId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValueId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ProposerN != 0 {
		i = encodeVarintPaxoskv(dAtA, i, uint64(m.ProposerN))
		i--
		dAtA[i] = 0x50
	}
	if m.LSN != 0 {
		i = encodeVarintPaxoskv(dAtA, i, uint64(m.LSN))
		i--
		dAtA[i] = 0x28
	}
	if m.Column != 0 {
		i = encodeVarintPaxoskv(dAtA, i, uint64(m.Column))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Instance) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Instance) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Instance) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Committed {
		i--
		if m.Committed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.Seen) > 0 {
		dAtA9 := make([]byte, len(m.Seen)*10)
		var j8 int
		for _, num1 := range m.Seen {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		i -= j8
		copy(dAtA[i:], dAtA9[:j8])
		i = encodeVarintPaxoskv(dAtA, i, uint64(j8))
		i--
		dAtA[i] = 0x32
	}
	if m.VBal != nil {
		{
			size, err := m.VBal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPaxoskv(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Val != nil {
		{
			size, err := m.Val.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPaxoskv(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}

func encodeVarintPaxoskv(dAtA []byte, offset int, v uint64) int {
	offset -= sovPaxoskv(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Request) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ops) > 0 {
		l = 0
		for _, e := range m.Ops {
			l += sovPaxoskv(uint64(e))
		}
		n += 1 + sovPaxoskv(uint64(l)) + l
	}
	if m.Bal != nil {
		l = m.Bal.Size()
		n += 1 + l + sovPaxoskv(uint64(l))
	}
	if m.Column != 0 {
		n += 1 + sovPaxoskv(uint64(m.Column))
	}
	if len(m.Instances) > 0 {
		for k, v := range m.Instances {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPaxoskv(uint64(l))
			}
			mapEntrySize := 1 + sovPaxoskv(uint64(k)) + l
			n += mapEntrySize + 2 + sovPaxoskv(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Reply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LastBal != nil {
		l = m.LastBal.Size()
		n += 1 + l + sovPaxoskv(uint64(l))
	}
	if len(m.Instances) > 0 {
		for k, v := range m.Instances {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPaxoskv(uint64(l))
			}
			mapEntrySize := 1 + sovPaxoskv(uint64(k)) + l
			n += mapEntrySize + 2 + sovPaxoskv(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *BallotNum) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.N != 0 {
		n += 1 + sovPaxoskv(uint64(m.N))
	}
	if m.Id != 0 {
		n += 1 + sovPaxoskv(uint64(m.Id))
	}
	return n
}

func (m *Cmd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovPaxoskv(uint64(l))
	}
	if m.Vi64 != 0 {
		n += 1 + sovPaxoskv(uint64(m.Vi64))
	}
	if m.ValueId != nil {
		l = m.ValueId.Size()
		n += 1 + l + sovPaxoskv(uint64(l))
	}
	return n
}

func (m *ValueId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Column != 0 {
		n += 1 + sovPaxoskv(uint64(m.Column))
	}
	if m.LSN != 0 {
		n += 1 + sovPaxoskv(uint64(m.LSN))
	}
	if m.ProposerN != 0 {
		n += 1 + sovPaxoskv(uint64(m.ProposerN))
	}
	return n
}

func (m *Instance) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Val != nil {
		l = m.Val.Size()
		n += 1 + l + sovPaxoskv(uint64(l))
	}
	if m.VBal != nil {
		l = m.VBal.Size()
		n += 1 + l + sovPaxoskv(uint64(l))
	}
	if len(m.Seen) > 0 {
		l = 0
		for _, e := range m.Seen {
			l += sovPaxoskv(uint64(e))
		}
		n += 1 + sovPaxoskv(uint64(l)) + l
	}
	if m.Committed {
		n += 2
	}
	return n
}

func sovPaxoskv(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPaxoskv(x uint64) (n int) {
	return sovPaxoskv(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPaxoskv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v Op
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPaxoskv
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= Op(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Ops = append(m.Ops, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPaxoskv
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPaxoskv
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPaxoskv
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Ops) == 0 {
					m.Ops = make([]Op, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v Op
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPaxoskv
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= Op(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Ops = append(m.Ops, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Ops", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaxoskv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPaxoskv
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPaxoskv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Bal == nil {
				m.Bal = &BallotNum{}
			}
			if err := m.Bal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Column", wireType)
			}
			m.Column = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaxoskv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Column |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaxoskv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPaxoskv
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPaxoskv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Instances == nil {
				m.Instances = make(map[int64]*Instance)
			}
			var mapkey int64
			var mapvalue *Instance
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPaxoskv
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPaxoskv
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPaxoskv
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPaxoskv
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPaxoskv
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Instance{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPaxoskv(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPaxoskv
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Instances[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPaxoskv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPaxoskv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Reply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPaxoskv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Reply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Reply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastBal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaxoskv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPaxoskv
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPaxoskv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastBal == nil {
				m.LastBal = &BallotNum{}
			}
			if err := m.LastBal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaxoskv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPaxoskv
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPaxoskv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Instances == nil {
				m.Instances = make(map[int64]*Instance)
			}
			var mapkey int64
			var mapvalue *Instance
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPaxoskv
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPaxoskv
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPaxoskv
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPaxoskv
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPaxoskv
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Instance{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPaxoskv(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPaxoskv
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Instances[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPaxoskv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPaxoskv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BallotNum) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPaxoskv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BallotNum: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BallotNum: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field N", wireType)
			}
			m.N = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaxoskv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.N |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaxoskv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPaxoskv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPaxoskv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPaxoskv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaxoskv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPaxoskv
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPaxoskv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vi64", wireType)
			}
			m.Vi64 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaxoskv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vi64 |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaxoskv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPaxoskv
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPaxoskv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ValueId == nil {
				m.ValueId = &ValueId{}
			}
			if err := m.ValueId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPaxoskv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPaxoskv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValueId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPaxoskv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValueId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValueId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Column", wireType)
			}
			m.Column = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaxoskv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Column |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LSN", wireType)
			}
			m.LSN = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaxoskv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LSN |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposerN", wireType)
			}
			m.ProposerN = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaxoskv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposerN |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPaxoskv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPaxoskv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Instance) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPaxoskv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Instance: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Instance: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaxoskv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPaxoskv
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPaxoskv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Val == nil {
				m.Val = &Cmd{}
			}
			if err := m.Val.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VBal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaxoskv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPaxoskv
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPaxoskv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VBal == nil {
				m.VBal = &BallotNum{}
			}
			if err := m.VBal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPaxoskv
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Seen = append(m.Seen, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPaxoskv
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPaxoskv
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPaxoskv
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Seen) == 0 {
					m.Seen = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPaxoskv
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Seen = append(m.Seen, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Seen", wireType)
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Committed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPaxoskv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Committed = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPaxoskv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPaxoskv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPaxoskv(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPaxoskv
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPaxoskv
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPaxoskv
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPaxoskv
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPaxoskv
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPaxoskv
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPaxoskv        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPaxoskv          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPaxoskv = fmt.Errorf("proto: unexpected end of group")
)
